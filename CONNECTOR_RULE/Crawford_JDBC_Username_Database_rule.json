{
  "description": "Rule to insert a record on username table on identity creation and update the email field in the existing record when an attribute synchronization event is triggered from ISC. ",
  "type": "JDBCProvision",
  "signature": {
    "input": [
      {
        "name": "log",
        "description": "The log object associated with the SailPointContext.",
        "type": null
      },
      {
        "name": "context",
        "description": "A sailpoint.api.SailPointContext object that can be used to query the database if necessary.\n  ",
        "type": null
      },
      {
        "name": "application",
        "description": "The application whose data file is being processed.",
        "type": null
      },
      {
        "name": "schema",
        "description": "The Schema currently in use.",
        "type": null
      },
      {
        "name": "connection",
        "description": "A connection object to connect to database.",
        "type": null
      },
      {
        "name": "plan",
        "description": "The ProvisioningPlan created against the JDBC application.",
        "type": null
      }
    ],
    "output": {
      "name": "result",
      "description": "A Provisioning Result object is desirable to return the status.IT can be a new object or part of  Provisioning Plan",
      "type": null
    }
  },
  "sourceCode": {
    "version": "1.0",
    "script": "import sailpoint.tools.Util;\r\nimport sailpoint.tools.GeneralException;\r\nimport sailpoint.object.ProvisioningPlan;\r\nimport sailpoint.object.ProvisioningResult;\r\nimport sailpoint.object.ProvisioningPlan.AccountRequest;\r\nimport sailpoint.object.ProvisioningPlan.AttributeRequest;\r\n\r\nimport java.sql.ResultSet;\r\nimport java.sql.Connection;\r\nimport java.sql.SQLException;\r\nimport java.sql.PreparedStatement;\r\n\r\n\t/**\r\n\t * @param accountRequest - username accountRequest\r\n\t * @param attribute - attributename to fetch from request\r\n\t * @return attribute value\r\n\t */\r\n    public String getAttributeRequestValue(AccountRequest acctReq, String attribute) {\r\n        if (acctReq != null) {\r\n            AttributeRequest attrReq = acctReq.getAttributeRequest(attribute);\r\n            if (attrReq != null) {\r\n                return attrReq.getValue();\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\t\r\n\t \r\n\t/**\r\n\t * @param employeeNumber - string employeeNumber\r\n\t * checks for employeeNumber uniqueness\r\n\t * @return boolean value\r\n\t */\r\n\tpublic boolean isEmployeeNumberUnique(String employeeNumber) {  \r\n    log.info(\"Entering isEmployeeNumberUnique()\");  \r\n  \r\n    boolean isUnique = true;  \r\n    if (Util.isNotNullOrEmpty(employeeNumber)) { \r\n        String selectQuery = \"SELECT COUNT(*) FROM [SailPoint_ISC_Dev].[dbo].[PrimaryUsernameTracking] WHERE EMPLOYEE_NUMBER = ?\";  \r\n        try {  \r\n            PreparedStatement preparedStatement = connection.prepareStatement(selectQuery);  \r\n            preparedStatement.setString(1, employeeNumber);  \r\n            ResultSet resultSet = preparedStatement.executeQuery();  \r\n            if (resultSet.next()) {  \r\n                int count = resultSet.getInt(1);  \r\n                if (count != 0) {\r\n                    isUnique = false;  \r\n                    log.debug(\"Unique UID found: \" + employeeNumber);  \r\n                } else {  \r\n                    log.debug(\"UID already exists: \" + employeeNumber);  \r\n                }  \r\n            }  \r\n          \r\n            preparedStatement.close();  \r\n        } catch (SQLException e) {  \r\n            log.error(\"Error checking UID uniqueness: \" + e.getMessage(), e);  \r\n        }  \r\n    }  \r\n  \r\n    log.info(\"Exiting isEmployeeNumberUnique()\");  \r\n    return isUnique;  \r\n }\r\n \r\n        ProvisioningResult result = new ProvisioningResult();\r\n        PreparedStatement statementCreate = null;\r\n        PreparedStatement statementModify = null;\r\n        PreparedStatement statementEnable = null;\r\n        PreparedStatement statementDisable = null;\r\n \r\n       String dbUserTableName = \"[SailPoint_ISC_Dev].[dbo].[PrimaryUsernameTracking]\";\r\n        String statusUserTableColumnName = \"Status\";\r\n        String uniqueIDUserTableColumnName = \"EMPLOYEE_NUMBER\";\r\n        log.debug(\"Employee UID:::\" + dbUserTableName);\r\n \r\n        if (plan != null) {\r\n \r\n            List<AccountRequest> accounts = plan.getAccountRequests();\r\n            if (accounts != null && !accounts.isEmpty()) {\r\n                for (AccountRequest account : accounts) {\r\n                String query=\"\";\r\n\t\t\t\t\r\n                    try {\r\n                        if (AccountRequest.Operation.Create.equals(account.getOperation())) {\r\n                           \r\n                            String lastName = getAttributeRequestValue(account, \"LAST_NAME\");\r\n                            String firstName = getAttributeRequestValue(account, \"FIRST_NAME\");\r\n                            String employeeNumber = account.getNativeIdentity();\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(isEmployeeNumberUnique(employeeNumber)) {\r\n\t\t\t\t\t\t\t//checks for any special characters in firstname and lastname\r\n                            if (!firstName.matches(\".*[a-zA-Z]+.*\") || !lastName.matches(\".*[a-zA-Z]+.*\")) {\r\n                                log.error(\"Error: FIRST_NAME or LAST_NAME cannot contain only special characters.\");\r\n                                log.error(\"Invalid FIRST_NAME: \" + firstName + \", LAST_NAME: \" + lastName);\r\n                                result.setStatus(ProvisioningResult.STATUS_FAILED);\r\n                                result.addError(new GeneralException(\"FIRST_NAME or LAST_NAME contains only special characters.\"));\r\n                                return result; // Exit immediately on error\r\n                            }\r\n\t\t\t\t\t\t\t\r\n                           HashMap attributeMap = new HashMap();\r\n                           StringBuilder columnNamesUserStringBuilder = new StringBuilder();\r\n                           StringBuilder columnValuesUserStringBuilder = new StringBuilder();\r\n\r\n                            String empType = null;\r\n                            boolean isFirst = true;\r\n                            List attributeRequestList = account.getAttributeRequests();\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t//loop to build create statement for columns and values for username table\r\n                            for (AttributeRequest attributeRequest : attributeRequestList) {\r\n \r\n                                String attributeName = attributeRequest.getName();\r\n                                if (isFirst) {\r\n                                    columnNamesUserStringBuilder.append(attributeName);\r\n                                    columnValuesUserStringBuilder.append(\"?\");\r\n                                    isFirst = false;\r\n                                } else {\r\n                                    columnNamesUserStringBuilder.append(\",\").append(attributeName);\r\n                                    columnValuesUserStringBuilder.append(\",?\");\r\n                                }\r\n                                attributeMap.put(attributeName, attributeRequest.getValue());\r\n                            }\r\n                            // Adding Employee number to the Map and builder as it is not being passed as attribute request\r\n                            // So setting EMPLOYEE_NUMBER as native identity\r\n                            // *Note: This is due to Employee_Number being account id and Account name on account schema.\r\n                            if(!attributeMap.containsKey(\"EMPLOYEE_NUMBER\")){\r\n                                attributeMap.put(\"EMPLOYEE_NUMBER\",employeeNumber);\r\n                                columnNamesUserStringBuilder.append(\",\").append(\"EMPLOYEE_NUMBER\");\r\n                                columnValuesUserStringBuilder.append(\",?\");\r\n                            }\r\n \r\n                            log.debug(\"ColumnNamesUserStringBuilder:::\" + columnNamesUserStringBuilder);\r\n \r\n \r\n                            query = \"INSERT INTO \" + dbUserTableName + \" (\" + columnNamesUserStringBuilder + \") VALUES (\" + columnValuesUserStringBuilder + \")\";\r\n                            statementCreate = connection.prepareStatement(query);\r\n                            int i = 1;\r\n \r\n                            for (String attributeName : columnNamesUserStringBuilder.toString().split(\",\")) {\r\n                                log.debug(\"attributevalue:::\" + attributeMap.get(attributeName) + \"AttributeName:::\" + attributeName);\r\n                                statementCreate.setString(i++, (String) attributeMap.get(attributeName));\r\n                            }\r\n                            \r\n                            statementCreate.executeUpdate();\r\n\t\t\t\t\t\t   }\r\n                            result.setStatus(ProvisioningResult.STATUS_COMMITTED);\r\n \r\n                        } else if (AccountRequest.Operation.Modify.equals(account.getOperation())) {\r\n                            String Email =   getAttributeRequestValue(account, \"EMAIL\");\r\n                            \r\n                            if (null != Email && null != account.getNativeIdentity()) {\r\n                                // throw new Exception(\"Email is \"+Email+\" \"+account.getNativeIdentity());\r\n                                statementModify = connection.prepareStatement(\r\n                                    \"UPDATE [SailPoint_ISC_Dev].[dbo].[PrimaryUsernameTracking] SET Email = ? WHERE EMPLOYEE_NUMBER = ?\");\r\n \r\n                                statementModify.setString(1, Email);\r\n                                statementModify.setString(2, (String) account.getNativeIdentity());\r\n                                statementModify.executeUpdate();\r\n                                // connection.commit();\r\n                            }\r\n                            result.setStatus(ProvisioningResult.STATUS_COMMITTED);\r\n \r\n                        } else if (AccountRequest.Operation.Disable.equals(account.getOperation())) {\r\n \r\n                            statementDisable = connection.prepareStatement(\r\n                                \"UPDATE [SailPoint_ISC_Dev].[dbo].[PrimaryUsernameTracking] SET STATUS = ? WHERE EMPLOYEE_NUMBER = ?\");\r\n \r\n                            statementDisable.setString(1, \"Inactive\");\r\n                            statementDisable.setString(2, (String) account.getNativeIdentity());\r\n                            statementDisable.executeUpdate();\r\n\t\t\t\t\t\t\t// connection.commit();\r\n \r\n                        } else if (AccountRequest.Operation.Enable.equals(account.getOperation())) {\r\n \r\n                            statementEnable = connection.prepareStatement(\r\n                                \"UPDATE [SailPoint_ISC_Dev].[dbo].[PrimaryUsernameTracking] SET STATUS = ? WHERE EMPLOYEE_NUMBER = ?\");\r\n \r\n                            statementEnable.setString(1, \"Active\");\r\n                            statementEnable.setString(2, (String) account.getNativeIdentity());\r\n                            statementEnable.executeUpdate();\r\n\t\t\t\t\t\t\t// connection.commit();\r\n                        }\r\n \r\n                    } catch (SQLException e) {\r\n                        result.setStatus(ProvisioningResult.STATUS_FAILED);\r\n                        result.addError(e);\r\n \r\n                        log.error(\"SQLException: \" + e.getMessage());\r\n \r\n                    } catch (GeneralException e) {\r\n                        result.setStatus(ProvisioningResult.STATUS_FAILED);\r\n                        result.addError(e);\r\n \r\n                        log.error(\"GeneralException: \" + e.getMessage());\r\n \r\n                    } finally {\r\n \r\n                        if (statementCreate != null) {\r\n                            statementCreate.close();\r\n                        }\r\n \r\n                        if (statementModify != null) {\r\n                            statementModify.close();\r\n                        }\r\n \r\n                        if (statementDisable != null) {\r\n                            statementDisable.close();\r\n                        }\r\n\t\t\t\t\t\t\r\n                        if (statementEnable != null) {\r\n                            statementEnable.close();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } \r\n        return result;"
  },
  "attributes": {
    "sourceVersion": "1.0"
  },
  "id": "d48ca140250e415f98870c268aa024dd",
  "name": "Crawford_JDBC_Username_Database_rule",
  "created": "2025-01-13T10:28:49.375Z",
  "modified": "2025-12-01T15:34:37.330Z"
}